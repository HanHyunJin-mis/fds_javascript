
# 함수
## 1. 함수란?
함수는 정의만으로 실행되지 않는다.

## 2. 함수의 사용 이유
`코드의 재사용 측면` 동일한 작업을 반복적으로 수행하기 위해
`함수의 유지보수 편의성`
`코드의 신뢰성 증가`

함수는 변수처럼 식별자를 붙일 수 있다.

## 3. 함수 리터럴
```javascript
// 변수에 함수 리터럴을 할당
var add = function add(x, y) {
  return x + y;
};
```
### 구성요소
`함수명`
- 식별자, 함수 몸체 안에서만 참조할 수 있는 식별자
- 함수명은 생략할 수 있다.

`매개변수`
- 0개 이상의 매개변수를 ()로 감싸고 ,로 구분한다.
- 인수가 할당된다.
- 함수 내에서 변수와 동일하게 취급한다.

`함수 몸체`
- 함수가 호출되었을 때 일괄적으로 실행하던 문 들을 하나의 실행 단위로 정의한 코드블럭

함수는 하나의 값을 생성하며 이 값은 객체이다.
=> 일반 객체는 호출 X, 함수는 호출 O

## 4. 함수 정의
함수를 정의하는 4가지 방법
1. 함수 선언문
```javascript
function add(x, y) {
  return x + y;
}
```
- 함수명을 생략할 수 없다.
- 즉, 함수 선언문 방식으로 생성된 함수를 호출한 것은 함수명 add이 아니라 자바스크립트 엔진이 암묵적으로 생성한 변수 add인 것이다. 

2. 함수 표현식
```javascript
var add = function (x, y) {
  return x + y;
};
```
3. Function 생성자 함수
```javascript
var add = new Function('x', 'y', 'return x + y');
```
4. 화살표 함수
```javascript
var add = (x, y) => x + y;
```
### 함수 선언문
```javascript
// 함수 선언문
function add(x, y) {
  return x + y;
}
```
`함수 선언문`
=> 변수명으로 호출                             
- 함수 리터럴 표기법과 형태가 동일

**함수 선언문은 함수명을 생략할 수 없다.**

- 함수 리터럴에서 함수명을 함수 몸체 내에서만 참조할 수 있다고 했다!!
=> 그렇다면 우리가 호출하고 참조했던 함수명은 무엇인가???
=> 함수 객체를 우리가 사용할 수 있게 하기 위해서 자바스크립트 엔진이 함수 객체를 할당할 변수를 생성(함수명과 동일)

### 함수 표현식
```javascript
// 함수 표현식
var add = function (x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
```
`함수 표현식`
=> javascript의 함수는 일급 객체이기 때문에 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다.
함수 리터럴의 함수명은 생략할 수 있다. -> 익명함수
**함수 호출 시에는 함수명이 아닌 함수 객체를 가리키는 변수를 사용해야 함!!**

### 함수 호이스팅
```javascript
// 함수 참조
console.dir(add); // ƒ add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```
- 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.
- 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출하게 되면 undefined가 출력된다.

### Function 생성자 함수
`생성자 함수` : 객체를 생성하는 함수

예시
```javascript
var add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5)); // 7
```
- 바람직하지 않은 방식
- `함수 선언문`과 `함수 표현식`은 렉시컬 스코프를 만들지만 `Function 생성자 함수`는 렉시컬 스코프를 만들지 않고 전역 함수인 것처럼 스코프를 생성한다.

### 화살표 함수
`화살표 함수` : function 키워드 대신 화살표를 사용하여 함수를 선언할 수 있다.
=> 항상 익명 함수로 정의한다.
예시
```javascript
// 화살표 함수
const add = (x, y) => x + y;

console.log(add(2, 5)); // 7
```
- 모든 상황에서 사용할 수 있는 것이 아니다.

## 5. 함수 호출
- 함수를 참조하는 `변수`와 `함수 호출 연산자(괄호)`로 호출한다.
- 호출되면 `매개변수`에 `인수`가 할당된다.

## 6. 매개변수와 인수
- `매개변수`를 통해 `인수`를 전달한다.
- `인수`는 함수를 호출할 때 지정하며 `개수와 타입에 제한이 없다.`

- `매개변수`는 함수를 정의할 때 선언한다. (undefined로 초기화)
- `매개변수`는 함수 외부에서는 참조할 수 없다.

매개변수보다 인수가 부족한 경우
- 매개변수의 값은 undefined가 된다.

인수가 초과되는 경우
- 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다.

## 7. 인수 확인
- 함수를 정의한 개발자의 의도와 다르게 함수가 작동될 수 있다.
=> javascript 함수는 적절한 인수가 전달되었는지 확인이 필요하다.

## 8. 매개변수의 개수
- ECMAScript 스펙에 정해져 있지는 않다.
- `매개변수`는 `순서에 의미`가 있다.
- `매개변수가 많아지면` 순서를 고려하기 어렵기 때문에 `적을 수록 좋고` `최대 3개 이상을 넘지 않는 것이 좋다.`

매개변수가 많아진다면?
=> 하나의 매개변수를 선언하고 `객체를 인수로 전달`받는 것이 유리하다.
=> 객체를 인수로 전달하면 매개변수의 순서를 신경쓰지 않아도 된다.

## 9. 외부 상태의 변경과 함수형 프로그래밍
`원시 값` -> 값에 의한 전달(pass by value) => 값 자체가 메모리에 저장된다, 값 자체를 복사
`객체` -> 참조에 의한 전달(pass by reference) => 객체의 참조 값(주소값)이 저장된다, 참조 값이 복사

```javascript
var person1 = {
  name: 'Lee'
};

var person2 = {
  name: 'Lee'
};

console.log(person1 === person2); // 참조 값 비교

console.log(person1.name === person2.name); // 원시 값 비교
```
`얕은 복사` : 참조값 복사
`깊은 복사` : 객체 자체를 복사하는 것

## 10. 반환문
- `return 키워드 + 반환값`으로 이루어진다.
return의 역할
1. 함수의 실행을 중단하고 함수 몸체를 빠져나간다.
2. return 키워드 뒤에 지정한 값을 반환


## 11. 다양한 함수의 형태

