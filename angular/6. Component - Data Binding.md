# Component - Data Binding
## 1. 데이터 바인딩이란?
- 뷰와 모델을 하나로 연결하는 것을 의미
- `템플릿(view)`과 `컴포넌트 클래스의 데이터(model)`를 하나로 묶어 유기적으로 동작하게 하는 것
- 기존의 웹 어플리케이션은 구조 상 문제로 뷰가 변경되면 로직도 변경될 가능성이 높다.
- angular는 `선언형 프로그래밍`을 한다.  
=> DOM에 직접 접근하지 않고 템플릿과 컴포넌트 클래스의 상호 관계를ㅈ 선언한다. (뷰와 모델의 관계를 관리)  
=> `데이터 바인딩`을 통해 `템플릿과 컴포넌트 클래스가 연결`된다. (템플릿 문법으로 기술)

## 2. 변화 감지
- 뷰와 모델의 동기화를 유지하기 위해 `상태의 변화를 감지`하고 이를 반영하는 것
- Angular의 양방향 바인딩은 `이벤트 바인딩 + 프로퍼티 바인딩`의 축약 표현이다. `[()]`

### 모델이 변화할 가능성이 있는 경우
- DOM 이벤트  
=> 일단 데이터가 바뀌었을 것이라고 생각한다.
- Timer 함수의 tick 이벤트
- Ajax 통신 / Promise 

=> 이 경우들에 변화 감지 툴이 감시한다.
`몽키패치` : 함수를 호출하면서 뷰를 갱신하는 일을 추가적으로 한다.
프록시...?

- 후킹 로직 내에서 변화 감지 수행, 변화가 감지되면 Digest loop를 실행하여 모델의 변화를 뷰에 반영

`#input이라는 템플릿 참조 변수를 {{input.value}}로 쓸 수는 없을까?`
- 데이터는 컴포넌트 클래스에서 관리해야 하는 것이고 뷰는 템플릿에서 관리해야 하는 것이다.
- 역할을 나누지 않으면 기존의 방식과 같은 것!

## 3. 데이터 바인딩
### 3-1 인터폴레이션
- `{{ expression }}`
- 표현식을 두개의 중괄호로 열고 닫은 형식
- `존재하지 않는 프로퍼티에 접근하는 경우 아무것도 출력하지 않는다.`  
=> 왜? 뷰가 데이터에 반응하면 곤란하다! 뷰는 데이터에 의해서 만들어지는 것

### 3-2 프로퍼티 바인딩
- `<element [property]="expression">...</element>`
- `컴포넌트 클래스의 프로퍼티`와 `템플릿` 간의 데이터 바인딩에 사용
- 객체를 포함하는 모든 값을 사용할 수 있음
- 어트리뷰트(id)를 가지고 프로퍼티(id)를 만든 것이다.

### 3-3 어트리뷰트 바인딩
- `<element [attr.attribute-name]="expression">...</element>`
- set attribute, get attribute

| HTML 어트리뷰트(attribute) | DOM 프로퍼티(property) |
| :---: | :---: | :---: |
| HTML 문서에 존재하는 것으로 어트리뷰트의 값은 변하지 않는다. | DOM 노드 객체에 있는 것으로 동적으로 변한다. |

```javascript
// HTMLInputElement.attributes.value의 값을 취득한다. 결과는 언제나 동일하다.
document.getElementById('user').getAttribute('value'); // ungmo2

// HTMLInputElement.value의 값을 취득한다. 결과는 요소의 상태에 따라 동적으로 변경된다.
document.getElementById('user').value;
```
- value의 경우, 어트리뷰트는 `DOM 프로퍼티의 초기 기본값을 의미`, DOM 프로퍼티는 `현재의 상태 값을 의미`
- `프로퍼티가 최신 값이 우선인 것이기 때문에 어트리뷰트와 프로퍼티를 같이 써주면 프로퍼티가 우선된다.`

#### 어트리뷰트가 항상 프로퍼티와 1 : 1로 매핑되는 것은 아니다.
- id 어트리뷰트와 id 프로퍼티는 1:1 매핑한다.
- class 어트리뷰트는 classList 프로퍼티로 변환된다.
- td 요소의 colspan 어트리뷰트의 경우, 매핑하는 프로퍼티가 존재하지 않는다.
- textContent 프로퍼티의 경우, 대응하는 어트리뷰트가 존재하지 않는다.
- input 요소의 value 어트리뷰트는 value 프로퍼티와 1:1 매핑하지만 서로 다르게 동작한다.
- 프로퍼티가 없는 경우 우리가 만든 컴포넌트에는 추가할 수 있지만 DOM은 직접 프로퍼티를 추가할 수 없다.

### 3-4 클래스 바인딩
#### 단항 클래스 바인딩
- `<div [class.alert]="isError">...</div>`
- `좌변`에는 `class 뒤에 HTML 요소의 class 어트리뷰트에 반영할 클래스 이름`을 지정, `우변`에는 `참, 거짓으로 평가되는 표현식`을 바인딩

#### 다항 클래스 바인딩
- `<div [class]="my-classes">...</div>`
- `좌변`에는 `class를 지정`하고 `우변`에는 `HTML 요소의 class 어트리뷰트에 반영할 클래스의 리스트`를 바인딩
- 이미 선언해 놓은 클래스를 덮어씌운다. => 단항 바인딩만 사용하는 것이 좋다.
- 여러개를 넣을 때는 ng class 바인딩을 사용하자!!

### 3-5 스타일 바인딩
- `<element [style.style-property]="expression">...</element>`
- HTML 요소의 style 어트리뷰트에 스타일을 지정할 수 있다.
- 단위가 필요한 경우에는 `css 프로퍼티에 단위를 추가`한다.

```HTML
<div [style.background-color]="'white'"
     [style.font-size.px]="'16'">...</div>
     <!-- fontSize 로 표기하는 것도 가능하다. -->
```

### 3-6 이벤트 바인딩
- `<element (event)="statement">...</element>`
- 뷰의 상태 변화에 의해 이벤트가 발생하면 이벤트 핸들러를 호출하는 것
- `$event 객체`는 DOM 이벤트의 종류에 의해 타입(KeyboardEvent, InputEvent, MouseEvent 등)이 결정  
=> $event.target.value
- 함수는 호출문을 작성해준다. => 인수를 전달해주기 위함

### 3-7 양방향 데이터 바인딩
- `<element [(ngModel)]="property">...</element>`
- 뷰와 컴포넌트 클래스의 상태 변화를 상호 반영하는 것  
=> 뷰 변화 -> 컴포넌트 클래스의 상태 변화, 컴포넌트 클래스 상태 변화 -> 뷰 변화


#### value라는 것은 html이 가지고 있는 것이다. $event.target.value를 써야 이벤트 타겟의 값이 넘어온다. (템플릿 참조 변수 대신에 사용할 수 있음)