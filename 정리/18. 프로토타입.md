- 프로토타입은 null이거나 객체이다.
  ( 상위 객체가 없을 수도 있고 있을 수도 있어서???? )

- 객체와 함수의 차이?

# 프로토타입

`프로토타입`이란?

- 함수의 부모 역할을 할 객체
- class도 함수이며 프로토타입 기반이다.
- javascript는 **프로토타입 기반의 객체지향 프로그래밍 언어**이다.

## 1. 객체 지향 프로그래밍

- 모든 것을 객체로 본다.

`상태 데이터`

- 바뀔 값
- 객체는 `상태`와 `동작`을 그룹핑한 것이다.

## 2. 상속과 프로토타입

- 모든 인스턴스가 동일한 내용의 메소드를 사용하면, 하나만 생성하여 모든 인스턴스가 공유하는 것이 바람직하다.

- `상속을 통해 불필요한 중복을 제거` => 프로토타입을 기반으로 상속을 구현

- 생성자 함수의 프로토타입에 메소드(getArea)를 추가한다.  
  => 생성자 함수가 생성한 모든 인스턴스가 공유할 수 있다.  
  =>자신의 상태를 나타내는 프로퍼티만을 개별적으로 소유하고 `내용이 동일한 메소드`는 `상속`을 통해 공유하여 사용하는 것이다.

`상속`이 왜 중요한가?  
=> 코드의 재사용이란 관점에서 유용하다.

=> 생성자 함수가 생성하는 모든 인스턴스가 공통으로 사용할 메소드나 프로퍼티를 `프로토타입에 미리 구현`해 놓으면 중복코드나 별도의 구현 없이 상위 객체인 `프로토타입`의 자산을 공유해서 사용할 수 있다.

- 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다?

ex. me.hasOwnProperty

|             me              |    hasOwnPropertyDescriptor     |
| :-------------------------: | :-----------------------------: |
|           `식별자`          |            `property`           |   |
|  => scope chain에서 찾는다. |  => prototype chain에서 찾는다. |   |

## 3. 프로토타입 객체

### 프로토타입 객체

- 객체 지향 프로그래밍에서 `상속을 구현하기 위해 사용`
- 어떤 객체의 상위 객체의 역할을 한다.
- 다른 객체에 공유 프로퍼티, 메소드를 제공한다.
- 생성자 함수가 생성할 인스턴스의 부모 역할

<br> 

- 모든 객체는 `[[Prototype]]`이라는 내부 슬롯을 갖는다.  
  => 모든 객체는 생성될 때 `[[Prototype]]` 내부 슬롯의 값으로 `프로토타입의 참조를 저장`한다.  
  => 즉, `모든 객체는 하나의 프로토타입을 갖으며` 프로토타입은 `객체의 생성 방식에 의해 결정`된다.
- `__proto__`는 `[[Prototype]]`에 저장되어 있는 객체를 참조한다.

### 객체의 생성 방식에 따른 프로토타입

|    객체 리터럴에 의해 생성     |         생성자 함수에 의해 생성된          |
| :----------------------------: | :----------------------------------------: |
|  Object.prototype(`제일 상위`) |  생성자 함수의 prototype 프로퍼티에 바인딩 |

- 프로토타입은 null이거나 객체이다.
  ( 상위 객체가 없을 수도 있고 있을 수도 있어서????, 아닌가 어떨 때 null이라는 거지 )

<br>

=> `객체`와 `프로토타입`과 `생성자 함수`는 서로 연결되어 있다.

|  프로토타입 -> 생성자 함수 접근  |  생성자 함수 -> ( 자신이 생성할 인스턴스의 )프로토타입 접근   | 객체 -> 자신의 프로토타입 객체 |
| :------------------------------: | :-----------------------------------------------------------: | :----------------------------: |
|      `constructor` 프로퍼티      |                     `prototype` 프로퍼티                      |  `__proto__` 접근자 프로퍼티   |

### 객체의 **proto**접근자 프로퍼티

- 모든 객체는 `__proto__접근자 프로퍼티`를 통해 자신의 프로토타입(`[[Prototype]]` 내부 슬롯)에 접근할 수 있다.

![star](https://user-images.githubusercontent.com/37561451/57273306-3835be00-70d2-11e9-8087-3fb2a9054261.png) - `__proto__`접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 `Object.prototype.__proto__`접근자 프로퍼티를 사용할 수 있다.

- 내부 슬롯은 프로퍼티가 아니다.
- 내부 슬롯에 `직접 접근할 수 없고` 간접적인 접근 방법을 제공해야 한다.

`접근자 프로퍼티` : `자체적으로는 값을 갖지 않고` `다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용`하는 접근자 함수(Accessor function)로 구성된 프로퍼티

### 함수 객체의 prototype 프로퍼티

`prototype 프로퍼티`는 함수 객체만 소유한다.

- 함수 객체는 `__proto__ 접근자 프로퍼티` 이외에 `prototype 프로퍼티도 소유`한다.
- 함수 객체의 `prototype 프로퍼티` : 생성자 함수가 생성할 인스턴스의 프로토타입

- non- constructer는 프로토타입이 생성되지 않는다, prototype 프로퍼티도 소유하지 않는다.  
  => 화살표 함수, 메소드 축약 표현으로 정의한 메소드)

모든 객체가 가지고 있는 `__proto__`접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype

### 프로토타입의 constructor 프로퍼티와 생성자 함수

- 모든 프로토타입은 `constructor 프로퍼티`를 갖는다.

- 이 constructor 프로퍼티는 `prototype 프로퍼티`로 자신을 참조하고 있는 생성자 함수를 자리킨다.

## 4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

- 우리가 배열을 arr = [1, 2, 3]이렇게 만들더라도 object에 Array가 오는 것은 똑같다.

<br>

- `생성자 함수`에 의해 `생성된 인스턴스`는 프로토타입의 `constructor 프로퍼티`에 의해 생성자 함수와 연결된다.

- new 연산자와 함께 생성자 함수를 호출해 인스턴스를 생성하지 않는 객체생성방식 존재

- 리터럴 표기법에 의해 생성된 객체의 경우에는 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 것이라고 단정할 수 없다.  
  => Object 생성자 함수는 new 연산자를 호출하지 않아도 new 연산자와 함게 호출한 것처럼 동일하게 작동한다.

- `리터럴 표기법에 의해 생성된 객체`도 `가상적인 생성자 함수`를 갖는다.

## 5. 프로토타입의 생성 시점

- 모든 객체는 생성자 함수와 연결되어 있다.  
  => 객체로서 모두 동일한 특성을 갖기 때문

- 프로토타입은 `생성자 함수가 생성되는 시점에 더불어 생성`된다.

### 사용자 정의 생성자 함수와 프로토타입 생성 시점

- 빌트인 생성자 함수가 아닌 사용자 정의 생성자 함수는 자신이 평가되어 함수 객체로 생성되는 시점에 프로토타입도 더불어 생성된다.  
  => 언제나 Object.prototype

### 빌트인 생성자 함수와 프로토타입 생성 시점

- 전역 객체 : Built - in을 내장하고 있는 객체를 프로퍼티로 갖는다.

## 6. 객체 생성 방식과 프로토타입의 결정

### 생성자 함수에 의해 생성된 객체의 프로토타입

- 프로토타입에도 프로퍼티를 추가, 삭제할 수 있다.

## 7. 프로토타입 체인

- 프로토타입 체인의 종점인 Object.prototype에서도 프로퍼티를 검색할 수 없는 경우, undefined를 반환

## 8. 캡슐화

- 즉시 실행 함수로 막고 생성자 함수를 반환
- 캡슐화를 클로저와 지역변수로 한다.

## 9. 오버라이딩과 프로퍼티 쉐도잉

`오버라이딩(Overriding)`

- 상위 클래스가 가지고 있는 메소드를 `하위 클래스가 재정의`하여 사용하는 방식이다.

`오버로딩(Overloading)`

- 함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메소드를 구현하고 `매개변수에 의해 메소드를 구별`하여 호출하는 방식이다.  
  ( 자바스크립트는 오버로딩을 지원하지 않지만 arguments 객체를 사용하여 구현할 수는 있다.)

- 프로토타입 메소드는 삭제되지 않는다.
- `프로토타입 프로퍼티를 변경 또는 삭제`하려면 하위 객체를 통해 프로토타입 체인으로 접근하는 것이 아니라 프로토타입에 직접 접근하여야 한다.

## 10. 프로토타입의 교체

- `프로토타입을 교체`하면 `constructor 프로퍼티와 생성자 함수 간의 링크가 파괴`

## 11. insteadof 연산자

- 상속 관계를 파악한다.
- 이항 연산자로서 `좌변에 객체를 가리키는 식별자`, `우변에 생성자 함수`를 가리키는 식별자를 피연산자로 받는다.
- 만약 `우변의 피연산자가 함수가 아닌 경우`, TypeError가 발생

## 12. Object.create에 의한 직접 상속

- new 연산자가 없이도 객체를 생성할 수 있다.
- 프로토타입을 지정하면서 객체를 생성할 수 있다. 이때 생성자 함수와 프로토타입 간의 링크가 파괴되지 않는다.
- 객체 리터럴에 의해 생성된 객체도 상속받을 수 있다.

## 13. 객체 리터럴 내부에서 **proto**에 의한 직접 상속

- Object.create는 두번째 인자로 프로퍼티를 정의하는 것이 번거롭다.

그래서

- ES6에서는 객체 리터럴 내부에서 `__proto__ 접근자 프로퍼티`를 사용하여 직접 상속을 구현할 수 있다.

## 14. 정적 프로퍼티/메소드

- 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메소드

## 15. 프로퍼티 존재 확인

- in 연산자는 `객체 내에 프로퍼티가 존재하는지` 여부를 확인

## 16. 프로퍼티 열거

- for…in 문을 사용

`for (변수선언문 in 객체) { … }`
<<<<<<< HEAD

- 객체의 프로퍼티 개수만큼 반복
=======
-  객체의 프로퍼티 개수만큼 반복
>>>>>>> d9c3eb61ec59b71e3675c76ec5bb8cf9a0858be9
- 변수 선언문에서 선언한 변수에 프로퍼티 키를 할당
