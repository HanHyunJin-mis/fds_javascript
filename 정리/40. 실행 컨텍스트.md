# 실행 컨텍스트
## 1. 실행 컨텍스트?
- 식별자, 스코프, 호이스팅, 클로저 등의 동작 원리를 담고 있는 자바스크립트의 핵심 개념  
- 코드 실행에 필요한 정보 저장하고 코드의 실행 결과 관리
- 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역
-식별자(변수, 함수, 클래스, this 등)를 등록하고 관리하기 위한 스코프와 실행 순서 관리를 구현한 내부 매커니즘으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리
=> 실행 컨텍스트를 보고 this를 결정한다.


### 알 수 있는 것
- 식별자와 식별자에 바인딩된 값을 관리하는 방식
- 호이스팅이 발생하는 이유
- 클로저의 동작  방식

## 2. 실행 가능한코드
- 각 유형마다 실행 컨텍스트를 생성하는 과정, 관리 내용이 다르다.

1. 전역 코드
- 전역 객체, 전역 스코프와 밀접한 관련을 가진다.
- 전역 스코프는 전역 코드를 만든다.
 지역 스코프 : 전역 스코프를 최상위를 가지는 스코프 체인의 일원으로 존재

2. 함수 코드
3. eval 코드
4. 모듈 코드

## 3. 실행 가능한 코드의 평가와 실행
- `코드의 평가` : 평가 과정에서 `실행 컨텍스트가 생성`된다.
- 변수, 함수, 클래스 등의 `선언문`이 평가되어 그 결과가 생성된 실행 컨텍스트에 등록  
- 코드 평가 => 선언 후 코드 실행(런타임) => 할당  
=> 식별자와 값을 바인딩  
=> 식별자를 찾는다. 어디에서? `실행 컨텍스트에서`  
=> 식별자를 찾으면 거기에 undefined 대신 할당


변수
var와 const
var - 전역 객체의 프로퍼티로 저장된다.
const - 전역 스코프에 저장된다.

=> 코드 실행에 필요한 정보도 `실행 컨텍스트에서 취득`하고 코드의 실행 결과도 `실행 컨텍스트에서 관리`된다.

## 4. 실행 컨텍스트의 역할
1. 전역 코드 평가
2. 전역 코드 실행
3. 함수 코드 평가
- foo.arguments를 폐지

4. 함수 코드 실행
- 식별자 console을 검색한다.
- 스코프 체인에 등록되어 있지 않고 전역 객체의 프로퍼티로 존재한다.
- 전역 객체의 프로퍼티는 전역 스코프에 있는 것처럼 보여진다.
- log는 console 객체의 프로퍼티이다.  


코드가 평가되고 실행되려면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다. => 실행 컨텍스트가 관리
1. 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등, 프로퍼티는 식별자라고 잘 안부른다. 프로퍼티는 프로토타입 체인에서 찾기 때문)를 스코프를 구분하여 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리할 수 있어야 한다.

2. 스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 즉, 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다.

3. 현재 실행 중인 코드의 실행 순서를 변경(예를 들어 함수 호출에 의한 실행 순서 변경)할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.

## 5. 실행 컨텍스트 스택
- 코드의 `실행 순서`를 관리한다.
- 브라우저를 키자마자 전역 객체 생성, web api, built-in 객체 => js 파일이 로드되고 파싱이 되자마자 => 전역 코드 평가 => 전역 실행 컨텍스트 생성
- 함수 호출 => 함수 실행 컨텍스트 생성

- 이 때 생성된 모든 실행 컨텍스트는 `스택(후입 선출) 자료구조`로 관리된다.  
=> push와 pop으로 구현할 수 있다.
- 큐(선입 선출)
=> push와 shift로 구현할 수 있다.

예시
```javascript
const x = 1;

function foo () {
  const y = 2;

  function bar () {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```
1. 전역 코드의 평가와 실행
2. foo 함수 코드의 평가와 실행
3. bar 함수 코드의 평가와 실행
4. foo 함수 코드로 복귀
5. 전역 코드로 복귀

=> 전역 코드는 더 이상 실행할 코드가 없을 경우 `대기 상태`로 들어간다.  
=> `전역 코드가 생성한 전역 실행 컨텍스트는 소멸하지 않고 애플리케이션이 종료될 때(웹 페이지에서 나가거나 브라우저를 닫을 때)까지 유지된다.`  
=> why? ex. 중간에 eventhandler가 있을 때 처리를 못한다.


동기식 처리 모델 : 하나의 처리가 종료되어야 다음 처리를 실행할 수 있는 것
=> 실행 컨텍스트가 하나이면 비동기적 처리를 할 수가 없다.
비동기식 처리 모델 : 하나의 처리가 종료되지 않은 상태라 하더라도 대기하지 않고 다음 태스크를 실행하는 것
=> 순차적으로 실행되지 X, 가독성이 좋지 않고 콜백 헬 유발, 에러 처리 어려움

## 6. 렉시컬 환경
- 식별자가 선언되는 환경, 렉시컬 스코프를 말한다. (스코프를 의미)
- `스코프와 식별자`를 관리  
- 단일 링크드 리스트의 형태를 띄고 있다.

### 역할
- 객체 형태의 `스코프를 만들고` `식별자를 등록`한다.
- 식별자에 바인딩된 `값을 관리`한다.

### 컴포넌트 구성
1. `환경 레코드` : 스코프에 포함된 식별자 등록, 식별자에 바인딩된 값을 관리
2. `외부 렉시컬 환경에 대한 참조` : 상위 스코프에 대한 참조, 단방향 링크드 리스트
3. `this 바인딩` : 외부에서 가지고 있는 메소드로 this값을 결정한다.
- `this를 참조하는 순간 메소드가 돌면서 값을 알 수 있다.`
- 화살표 함수는 this가 없고 상위의 this를 참조한다.
- a라는 화살표 함수는 a.bind(this)가 붙어 있다.


## 7. 실행 컨텍스트의 생성과 식별자 검색 과정
- 전역 객체도 Object.prototype을 상속받는다.

```
1. 전역 실행 컨텍스트 생성
2. 전역 렉시컬 환경 생성
  2.1. 전역 환경 레코드 생성
    - 전역 변수를 객체 환경 레코드와 선언적 환경 레코드 둘 중 하나에만 접근해서 찾으면 나머지 하나는 보지 않는다.

    2.1.1. 객체 환경 레코드 생성
      - var 키워드, foo 함수
      - window의 메소드로 등록된다.
    2.1.2. 선언적 환경 레코드 생성
      - 숨겨진 전역 부분, let과 const
      - window.으로 찾을 수 없다.
      - 전역 객체가 아님

  2.2. 외부 렉시컬 환경에 대한 참조 할당
  2.3. this 바인딩
```
2.2. 외부 렉시컬 환경에 대한 참조 할당  
- 함수는 자신이 정의가 된 곳에서 평가된다.
- 함수는 평가될 때 현재 실행중인 실행 컨텍스트가 자신의 상위 스코프이다.
- 자신의 상위 스코프를 항상 들고 다닌다.
- 함수 객체의 내부 슬롯에 `[[Environment]]`라는 것을 들고 다닌다.  
=> 자바스크립트의 모든 함수는 자신의 상위 스코프를 기억하는 클로저이다.

```javascript
function(){
  console.log(x);
}

Object.prototype.x = 1;

foo(); // 1
```
- 전역 객체도 Object.prototype을 참조할 수 있기 때문에 x를 찾을 수 있다.
- window 객체의 프로토타입 체인상 위로 올라가면 Object.prototype 존재


```javascript
const foo = function(){
  console.log(x);
}

Object.prototype.x = 1;

foo();
```

8. 실행 컨텍스트와 블록 레벨 스코프
- foo의 렉시컬 환경을 만들고 for 문을 만나면 실행 컨텍스트가 없는 block 렉시컬 환경을 만든다.
- 블록은 실행 가능한 코드로 만들지 않는다.