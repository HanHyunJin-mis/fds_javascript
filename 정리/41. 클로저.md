# 클로저
**면접 단골 질문**
- 실행 컨텍스트 관련해서 말하는 것이 좋다.

- 자신을 포함하고 있는 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 외부 함수 밖에서 중첩 함수를 호출하더라도 외부 함수의 지역 변수에 접근할 수 있는 함수
- 자신이 자신의 상위 스코프를 기억하고 그 상위 스코프의 식별자를 하나라도 참조하는 함수 && 중첩 함수가 외부 함수보다 더 오래 살아있는 경우
- 클로저는 매커니즘

`[[Environment]]` : 함수 객체의 내부 슬롯
- 함수 객체는 `내부 슬롯[[Environment]]`에 저장한 렉시컬 환경의 참조, 상위 스코프를 기억한다.

Object => 빌트인 객체

## 클로저의 목적
- 안전하게 상태 유지를 한다.
- 안전하게 : 자격이 되는 것들만 변경할 수 있는 것
- 상태 유지를 할 수 있는 것 : 프로퍼티  
=> 객체의 모든 프로퍼티는 private 하지 않고 public하다.

## 클로저의 특징
- `최신 상태를 유지한다.` => `상태를 안전하게 유지하기 위해서 사용`  
=> 캡슐화는 정보은닉을 하는 방식이다. (같은 것이 아님!)
- 클로저도 고차함수이다. (함수를 반환하기 때문)
- 함수는 일급 객체이므로 반환이 가능하다.

- 이론적으로 모든 함수는 클로저다.
- 하지만 상위 스코프의 식별자를 참조하지 않는 경우 `브라우저 최적화`를 통해 상위 스코프를 기억하지 않는다.
=> 클로저라고 할 수 없다.

- 브라우저가 click이벤트가 발생하면 이벤트 큐에 함수 객체가 들어갔다 콜 스택이 비면 실행한다.
- return하기 직전 객체가 된다.
=> 메소드도 객체를 만들 때 만들어진다.

- 함수는 외부 상태를 변경하지 않는다. => 순수 함수

let
for문이 돌 때마다 각각 독립적인 lexical 환경을 생성한다.  
참조가 이루어지지 않으면 사라진다.  
for in : 객체들의 프로퍼티를 순회할 때 사용
for of : const를 사용할 수 있다. 모든 이터레이터들을 순회할 수 있음
```javascript
const arr = [1, 2, 3, 4, 5];
for(const item of arr) {
  console.log(item);
}

var arr = [1, 2, 3, 4, 5];

for(var _i = 0, _arr = arr; _i < _arr.length; _i++){
  var item = _arr[_i];
  console.log(item);
}
```