# SPA & Routing

## SPA란 무엇인가?
`웹 페이지` : 단순 정보만을 취득하는 것
`웹 어플리케이션` : 자신이 무슨 데이터를 입력하고 저장하는 등과 같은 일을 하는 것

## SPA의 장점
- 사용자 경험이 네이티브 앱과 비교했을 때 좋다. (깜빡거리지 않음)

## SPA의 단점

## Routing이란?
- 출발지에서 목적지까지의 경로를 결정하는 기능
- 화면 전환하는 것
어떻게 화면 전환을 할 수 있을까?

## 브라우저가 화면을 전환하는 경우
`화면 전환` : html이 다시 렌더링 되는 것
`SEO` : SEO가 되려면 고유의 url을 가지고 있어야 한다.
1. 주소창에 url을 입력하면 해당 페이지로 이동하는 경우
2. 웹페이지의 링크를 클릭하면 해당 페이지로 이동하는 경우
3. 브라우저의 뒤로 가기, 앞으로 가기 버튼(새로고침 포함)을 클릭하면 방문했던 페이지로 이동하는 경우

브라우저가 history를 관리하기 위해서는 각 페이지가 브라우저의 주소창에서 구별할 수 있는 유일한 url을 가져야 한다.


## 실행 방법
## 1. 전통적 link 방식
- `http://172.30.83.121:5001/service`
- link 태그로 동작하는 방식
- /은 index.html로 가는 링크이다.

### 특징
- 어트리뷰트의 값인 리소스의 경로가 url(path)에 추가되어 주소창에 나타난다.
- 해당 리소스를 `서버에 요청`  
=> 서버가 완전한 리소스를 클라이언트에 응답한다. (`서버 렌더링`)

### 장점
- 구현하기 편하다. => javascript가 필요없다.
- SEO가 가능하다.

### 단점
- 결국 전체 페이지를 다시 렌더링하게 된다.
=> 각 페이지마다 고유의 url이 존재

## 2. AJAX 방식
- `http://172.30.83.121:5002/`
- 전통적 방식은 화면을 전환하는 과정에서 전체 페이지를 새로 렌더링 해야 한다. => 속도 저하의 요인
- 이것을 보완하기 위해 `AJAX 방식이 등장 `하였다.  

### 특징
- 비동기적으로 서버와 브라우저가 데이터 교환이 가능해짐  
=> 페이지의 일부분만을 갱신
- `href 어트리뷰트`를 사용하지 않는다.
- link 요소가 클릭되면 link tag의 기본 동작을 막고(`preventDefault`) `AJAX를 사용하여 서버에 필요한 리소스를 요청`한다.
- 일부분만을 갱신하기 때문에 `url을 변경시키지 않는다.`

### 장점
- 불필요한 리소스가 중복 요청되지 않는다.
- 페이지의 일부분만 갱신되어 빠른 퍼포먼스와 부드러운 화면 표시를 기대할 수 있다.

### 단점
- javascript를 작성해주어야 하고 link tag의 기본 동작을 막아야 한다.
- `history관리`가 동작되지 않는다.
- 하나의 주소로 동작하기 때문에 `SEO 문제 발생`
- reload하면 home으로 돌아간다. => url을 가지고 다시 요청하기 때문에

#### 왜 link가 안변하는가?  
- 주소창으로 화면전환을 하는 것을 막았기 때문에

## 3. Hash 방식
- `http://172.30.83.121:5003/#service`
- AJAX 방식은 history가 관리되지 않는다. 이것을 보완하기 위한 방식

### 특징
잘 알아둘 것
`DOMContentLoaded` : 리소스는 아직이더라도 DOM이 완성된 것
`load 이벤트` : 모든 리소스가 불러와진 것 => 리소스가 다 불러진 다음 그것을 사용할 때
- URI의 고유 기능인 `anchor`를 사용한다.
```html
<li>
  <a href="#service">Service</a>
</li>  
```
=> href 어트리뷰트에 #을 사용한다.
- URL이 동일한 상태에서 hash가 변경되면 브라우저가 서버에 어떠한 요청도 하지 않는다.  
=> `hash가 변경되어도 서버에 새로운 요청을 보내지 않으며 페이지가 갱신되지 않는다.`  
=> hash는 페이지 내의 이동이기 때문에
- hash는 웹 페이지 내부에서 이동을 위한 것!
- hash의 변경을 감지하면 필요한 AJAX 요청을 수행한다.

### 장점
- 서버에 새로운 요청을 보내지 않는다.
- 페이지가 갱신되지 않아도 `페이지마다 고유의 URL이 존재`하므로 `history 관리에 문제가 없다.`

### 단점 
- URI에 불필요한 `#`가 들어간다는 것
**#! : hash- bang**
- SEO 이슈 : 크롤러가 hash 방식으로 만들어진 사이트의 콘텐츠를 수집할 수 없다.  
=> 구글 검색 엔진은 `해시뱅을 일반 url로 변경`시켜 문제를 해결했다. 하지만 다른 검색 엔진은 수집 불가!

## 4. PJAX 방식
- `http://172.30.83.121:5004/service`
- hash 방식에서 문제였던 SEO 이슈를 보완해준다.
- `서버 렌더링 방식` + `AJAX 방식`

### 특징
- HTML5의 History API인 `pushState`와 `popstate 이벤트`를 사용한다.
- href 어트리뷰트에 path를 사용한다.
- 클릭 이벤트가 발생하면 이벤트는 캐치하고 서버로의 요청을 방지한다.  
=> path를 사용하여 AJAX 요청을 한다.
- 이 때, AJAX는 주소창의 url을 변경시키지 않아서 `history의 관리`가 불가능하다.  
=> `pushState 메소드`를 사용하여 보완
- `pushState 메소드` : 주소창의 url을 변경하고 url을 history entry로 추가하지만 요청은 하지 않는다. (요청하게 되면 다시 렌더링하는 것이기 때문에)
- 이전 페이지, 다음 페이지 버튼이 클릭되면 router를 호출한다.

### 정리
- `history 관리` : pushState를 사용, 페이지마다 고유의 url 존재
- `페이지 갱신 문제` : 서버에 새로운 요청을 보내지 않음

### 단점
- 페이지의 새로 고침 버튼을 클릭하게 되면 새로운 요청이 서버로 전달된다.
- 서버와 협력해서 이동이 많으면 많아질수록 리소스를 많이 써줘야 한다.

```javascript
 const routes = {
    '/': function () {
      get('/data/home.json')
        .then(res => render(res));
    },
    '/service': function () {
      get('/data/service.json')
        .then(res => render(res));
    },
    '/about': function () {
      get('/data/about.html')
        .then(res => renderHtml(res));
    },
    otherwise(path) {
      root.innerHTML = `${path} Not Found`;
    }
  };
```

전역변수를 사용하지 않는 방법  
- 모듈 : 파일 스코프를 가지게 해서 노출될 것만 노출.  
=> es6의 모듈과 node의 모듈은 다른 것
- 즉시실행함수
- 전역 객체
- 클로저?