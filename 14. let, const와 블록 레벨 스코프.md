1. 값을 할당하지 않으면 계속 에러가 나야 하는 것이 아닌가?
2. console.log(x);
const x = 10; 이렇게 하면 
Uncaught ReferenceError: Cannot access 'x' before initialization
이렇게 나오는데 그렇다면 const는 초기화가 된다는 것인가요?? 초기화가 이루어진다면 언제 이루어지나요?

# let, const와 블록 레벨 스코프
## 1. var 키워드로 선언한 변수의 문제점

### 변수 중복 선언 허용
- 중복 선언 가능
  => 같은 변수명으로 var 키워드를 선언하면 `var 키워드가 없는 것처럼 동작`

### 함수 레벨 스코프
- 오로지 `함수의 코드 블록만을 지역 스코프로 인정`
  => `함수 외부의 var 변수`는 모두 `전역 변수`

### 변수 호이스팅
- 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작
- var 키워드로 선언한 변수는 변수 선언문 이전에 참조 가능
  => 단, undefined가 나옴

## let 키워드
**var의 단점을 보완하기 위해 ES6에서 let, const를 도입**

### 변수 중복 선언 금지
- var 키워드로 중복 선언하면 나중에 선언된 변수의 값으로 덮어쓴다.
- let 키워드로 동일한 이름을 갖는 변수를 중복 선언하면 syntaxError가 발생한다.

### 블록 레벨 스코프
- let 키워드로 선언한 변수는 모든 코드 블록(함수, if문, for문, while문, try/catch문 등) 지역 스코프로 인정하는 `블록 레벨 스코프`를 따른다.
=> var는 `함수 레벨 스코프`

### 변수 호이스팅
- let 키워드로 선언한 변수는 `변수 호이스팅이 발생하지 않는 것처럼 동작한다.`
- let 키워드로 선언한 변수를 선언문 이전에 참조하면 referenceError가 발생한다.
=> `선언 단계`와 `초기화 단계`가 분리되어 진행되기 때문
=> `초기화 단계`가 변수 선언문에 도달했을 때 실행된다.
- `일시적 사각지대` : 스코프의 시작 지점부터 초기화 시작 지점까지의 구간

```javascript
let foo = 1; // 전역 변수

{
  console.log(foo); // ReferenceError: foo is not defined
  let foo = 2; // 지역 변수
}
```
- 변수 호이스팅이 발생하지 않는다면 위 예제는 전역 변수 foo의 값을 출력해야 한다.
=> 하지만 referenceError 발생

- 자바스크립트는 ES6에서 도입된 let, const를 포함하여 모든 선언(var, let, const, function, function*, class 등)을 호이스팅한다.

### 전역 객체와 let
- 전역 객체는 모든 객체의 유일한 최상위 객체를 의미
=> `브라우저 환경`에서는 `window 객체`, `Node.js 환경`에서는 `global 객체`

- var로 선언한 전역변수, 암묵적 전역 변수, 전역 함수
=> `전역 객체의 프로퍼티`가 된다.
=> 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.

하지만!!

- let 키워드로 선언한 전역 변수는 `전역 객체 window의 프로퍼티가 아니다.`
=> `window.x 처럼 접근할 수 없다.`
=> let 전역 변수는 보이지 않는 개념적인 블록 내에 존재하게 된다.

## const 키워드
- 상수를 선언하기 위해 사용하지만 `반드시 상수만을 위해 사용하지는 않는다.`

### 선언과 초기화
- 재할당이 금지
- `const 키워드로 선언한 변수는 반드시 선언과 동시에 할당이 이루어져야 한다.`
=> undefined 말고!

### 상수
- 상수는 일반적으로 변수명을 대문자로 선언한다.

### const 키워드와 객체
- 재할당이 금지된다.
- 원시 값을 할당한 경우 원시 값은 변경 불가능하고 재할당이 금지되므로 변경할 수 없다.
=> 하지만 객체는 변경 가능하다. ` 단, 재할당을 금지할 뿐`

## 4. var vs. let vs. const

